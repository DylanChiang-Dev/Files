# Personal Build Workflow
# 用于个人设备安装的简化打包流程，使用自签名证书

name: Build Personal (Self-Signed)

on:
  workflow_dispatch:
    inputs:
      platform:
        description: '打包平台'
        required: true
        default: 'x64'
        type: choice
        options:
          - x64
          - arm64
          - x64|arm64

jobs:
  build:
    runs-on: windows-latest
    env:
      SOLUTION_NAME:           'Files.slnx'
      CONFIGURATION:           'Release'
      PLATFORM:                'x64'
      APPX_BUNDLE_PLATFORMS:   '${{ github.event.inputs.platform }}'
      WORKING_DIR:             '${{ github.workspace }}'
      ARTIFACTS_STAGING_DIR:   '${{ github.workspace }}\artifacts'
      APPX_PACKAGE_DIR:        '${{ github.workspace }}\artifacts\AppxPackages'
      PACKAGE_PROJECT_DIR:     'src\Files.App (Package)'
      PACKAGE_PROJECT_PATH:    'src\Files.App (Package)\Files.Package.wapproj'
      PACKAGE_MANIFEST_PATH:   'src\Files.App (Package)\Package.appxmanifest'
      LAUNCHER_PROJECT_PATH:   'src\Files.App.Launcher\Files.App.Launcher.vcxproj'
      # 自签名证书发布者 (可自定义)
      SELF_SIGN_PUBLISHER:     'CN=Files Personal Build'

    steps:
    - name: Checkout the repository
      uses: actions/checkout@v4

    - name: Setup MSBuild
      uses: microsoft/setup-msbuild@v2

    - name: Setup NuGet
      uses: NuGet/setup-nuget@v2

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        global-json-file: global.json

    - name: Generate self-signed certificate
      shell: pwsh
      run: |
        $cert = New-SelfSignedCertificate `
          -Type Custom `
          -Subject "$env:SELF_SIGN_PUBLISHER" `
          -KeyUsage DigitalSignature `
          -FriendlyName "Files Personal Build Certificate" `
          -CertStoreLocation "Cert:\CurrentUser\My" `
          -TextExtension @("2.5.29.37={text}1.3.6.1.5.5.7.3.3", "2.5.29.19={text}")
        
        # 导出证书供用户安装
        $certPath = "$env:ARTIFACTS_STAGING_DIR\FilesPersonalBuild.cer"
        New-Item -ItemType Directory -Force -Path $env:ARTIFACTS_STAGING_DIR
        Export-Certificate -Cert $cert -FilePath $certPath
        
        # 保存证书指纹
        echo "CERT_THUMBPRINT=$($cert.Thumbprint)" >> $env:GITHUB_ENV
        Write-Host "Certificate generated with thumbprint: $($cert.Thumbprint)"

    - name: Configure package manifest for personal build
      shell: pwsh
      run: |
        # 更新 Package.appxmanifest 中的 Publisher
        [xml]$manifest = Get-Content $env:PACKAGE_MANIFEST_PATH
        $manifest.Package.Identity.Publisher = $env:SELF_SIGN_PUBLISHER
        $manifest.Package.Identity.Name = "FilesPersonal"
        $manifest.Package.Properties.DisplayName = "Files (Personal)"
        $manifest.Package.Applications.Application.VisualElements.DisplayName = "Files (Personal)"
        $manifest.Save($env:PACKAGE_MANIFEST_PATH)
        
        # 更新应用图标路径（使用 Release 图标）
        Get-ChildItem $env:WORKING_DIR -Include *.csproj, *.appxmanifest, *.wapproj, *.xaml -Recurse | ForEach-Object {
          (Get-Content $_ -Raw) -replace "Assets\\AppTiles\\Dev", "Assets\AppTiles\Release" | Set-Content $_ -NoNewline
        }
        
        # 替换占位符（使用空值，这些功能在个人版中不可用）
        Get-ChildItem $env:WORKING_DIR -Include *.cs -Recurse | ForEach-Object {
          $content = Get-Content $_ -Raw
          $content = $content -replace "cd_app_env_placeholder", "SideloadStable"
          $content = $content -replace "bingmapskey.secret", ""
          $content = $content -replace "sentry.secret", ""
          $content = $content -replace "githubclientid.secret", ""
          $content | Set-Content $_ -NoNewline
        }

    - name: Use Windows SDK Preview
      shell: cmd
      run: |
        for /f %%a in ('dir /b /a:d %localappdata%\Microsoft\VisualStudio\17*') do echo UsePreviews=True>%localappdata%\Microsoft\VisualStudio\%%a\sdk.txt

    - name: Restore Files
      shell: pwsh
      run: |
        msbuild $env:SOLUTION_NAME `
          -t:Restore `
          -p:Platform=$env:PLATFORM `
          -p:Configuration=$env:CONFIGURATION `
          -p:PublishReadyToRun=true

    - name: Restore NuGet for Launcher
      shell: pwsh
      run: |
        nuget restore "$env:LAUNCHER_PROJECT_PATH" `
          -SolutionDirectory "$env:WORKING_DIR"

    - name: Build Launcher
      shell: pwsh
      run: |
        msbuild "$env:LAUNCHER_PROJECT_PATH" `
          -t:Build `
          -p:Platform=$env:PLATFORM `
          -p:Configuration=$env:CONFIGURATION

    - name: Build & Package Files
      shell: pwsh
      run: |
        msbuild "$env:PACKAGE_PROJECT_PATH" `
          -t:Build `
          -t:_GenerateAppxPackage `
          -p:Platform=$env:PLATFORM `
          -p:Configuration=$env:CONFIGURATION `
          -p:AppxBundlePlatforms=$env:APPX_BUNDLE_PLATFORMS `
          -p:AppxPackageDir="$env:APPX_PACKAGE_DIR" `
          -p:AppxBundle=Always `
          -p:UapAppxPackageBuildMode=Sideload `
          -p:GenerateAppInstallerFile=False `
          -p:AppxPackageSigningEnabled=True `
          -p:PackageCertificateThumbprint=$env:CERT_THUMBPRINT

    - name: Create one-click installer script
      shell: pwsh
      run: |
        # 一键安装脚本
        $installScript = @'
        # Files Personal Build - 一键安装脚本
        # 右键此文件 -> 使用 PowerShell 运行
        
        param([switch]$Uninstall)
        
        $ErrorActionPreference = "Stop"
        $scriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path
        
        # 检查管理员权限
        $isAdmin = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")
        
        if (-not $isAdmin) {
            Write-Host "需要管理员权限，正在请求..." -ForegroundColor Yellow
            Start-Process PowerShell -Verb RunAs -ArgumentList "-ExecutionPolicy Bypass -File `"$($MyInvocation.MyCommand.Path)`""
            exit
        }
        
        Write-Host "========================================" -ForegroundColor Cyan
        Write-Host "   Files Personal Build 安装程序" -ForegroundColor Cyan
        Write-Host "========================================" -ForegroundColor Cyan
        Write-Host ""
        
        # 查找证书和安装包
        $certFile = Get-ChildItem -Path $scriptDir -Filter "*.cer" | Select-Object -First 1
        $msixBundle = Get-ChildItem -Path $scriptDir -Recurse -Filter "*.msixbundle" | Select-Object -First 1
        
        if (-not $certFile) {
            Write-Host "错误: 找不到证书文件 (.cer)" -ForegroundColor Red
            pause
            exit 1
        }
        
        if (-not $msixBundle) {
            Write-Host "错误: 找不到安装包 (.msixbundle)" -ForegroundColor Red
            pause
            exit 1
        }
        
        # 步骤 1: 安装证书
        Write-Host "[1/2] 安装证书..." -ForegroundColor Green
        try {
            $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2($certFile.FullName)
            $store = New-Object System.Security.Cryptography.X509Certificates.X509Store("Root", "LocalMachine")
            $store.Open("ReadWrite")
            
            # 检查证书是否已安装
            $existing = $store.Certificates | Where-Object { $_.Thumbprint -eq $cert.Thumbprint }
            if ($existing) {
                Write-Host "  证书已安装，跳过" -ForegroundColor Gray
            } else {
                $store.Add($cert)
                Write-Host "  证书安装成功!" -ForegroundColor Green
            }
            $store.Close()
        } catch {
            Write-Host "  证书安装失败: $_" -ForegroundColor Red
            pause
            exit 1
        }
        
        # 步骤 2: 安装应用
        Write-Host "[2/2] 安装应用..." -ForegroundColor Green
        try {
            Add-AppxPackage -Path $msixBundle.FullName
            Write-Host "  应用安装成功!" -ForegroundColor Green
        } catch {
            Write-Host "  应用安装失败: $_" -ForegroundColor Red
            pause
            exit 1
        }
        
        Write-Host ""
        Write-Host "========================================" -ForegroundColor Cyan
        Write-Host "   安装完成! 可以在开始菜单找到 Files" -ForegroundColor Green
        Write-Host "========================================" -ForegroundColor Cyan
        Write-Host ""
        Write-Host "按任意键退出..."
        $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
        '@
        
        $installScript | Out-File -FilePath "$env:ARTIFACTS_STAGING_DIR\Install.ps1" -Encoding UTF8
        
        # 创建简单的 readme
        $readme = @"
Files Personal Build
====================

安装方法：
  右键点击 Install.ps1 -> 使用 PowerShell 运行

卸载方法：
  Windows 设置 -> 应用 -> 找到 "Files (Personal)" -> 卸载

注意：此为个人构建版本，部分在线功能不可用。
"@
        $readme | Out-File -FilePath "$env:ARTIFACTS_STAGING_DIR\README.txt" -Encoding UTF8

    - name: Remove empty files
      shell: bash
      run: find $ARTIFACTS_STAGING_DIR -empty -delete

    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: 'Files-Personal-Build-${{ github.event.inputs.platform }}'
        path: ${{ env.ARTIFACTS_STAGING_DIR }}
        retention-days: 30
